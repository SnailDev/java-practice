package com.snaildev;

import com.snaildev.bean.UserModel;
import com.snaildev.dao.IUserDao;
import org.junit.*;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.*;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JdbcTemplateTest {
    private static JdbcTemplate jdbcTemplate;

    @BeforeClass
    public static void setupClass() {
        String url = "jdbc:hsqldb:mem:test";
        String username = "sa";
        String password = "";

        DriverManagerDataSource dataSource = new DriverManagerDataSource(url, username, password);
        dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    public void test() {
        String sql = "select * from INFORMATION_SCHEMA.SYSTEM_TABLES";
        jdbcTemplate.query(sql, new RowCallbackHandler() {
            @Override
            public void processRow(ResultSet resultSet) throws SQLException {
                String value = resultSet.getString("TABLE_NAME");
                System.out.println("Column TABLENAME:" + value);
            }
        });
    }

    @Before
    public void setUp() {
        String createTableSql = "create memory table test(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name varchar(100))";
        jdbcTemplate.update(createTableSql);

        String createHsqldbFunctionSql = "CREATE FUNCTION FUNCTION_TEST(str CHAR(100)) returns INT begin atomic return length(str);end";
        jdbcTemplate.update(createHsqldbFunctionSql);

        String createHsqldbProcedureSql = "CREATE PROCEDURE PROCEDURE_TEST(INOUT inOutName VARCHAR(100), OUT outId INT) " +
                "MODIFIES SQL DATA BEGIN ATOMIC " +
                "INSERT INTO test(name) VALUES(inOutName); " +
                "SET outId = IDENTITY(); " +
                "SET inOutName='Hello,'+inOutName;" +
                "END";
        jdbcTemplate.update(createHsqldbProcedureSql);
    }

    @After
    public void tearDown() {
        jdbcTemplate.execute("DROP FUNCTION FUNCTION_TEST");
        jdbcTemplate.execute("DROP PROCEDURE PROCEDURE_TEST");
        String dropTableSql = "drop table test";
        jdbcTemplate.execute(dropTableSql);
    }

    @Test
    public void testCURD() {
        insert();
        delete();
        update();
        select();
    }

    private void select() {
        jdbcTemplate.query("select * from test", new RowCallbackHandler() {
            @Override
            public void processRow(ResultSet resultSet) throws SQLException {
                System.out.print("===========id:" + resultSet.getInt("id"));
                System.out.println(",name:" + resultSet.getString("name"));
            }
        });
    }

    private void update() {
        jdbcTemplate.update("UPDATE test set name='xiaoming' WHERE name=?", new Object[]{"xiaohong"});
        Assert.assertEquals(1, (int) jdbcTemplate.queryForObject("SELECT COUNT(*) FROM test WHERE name='xiaoming'", Integer.class));
    }

    private void delete() {
        jdbcTemplate.update("DELETE FROM test WHERE name=?", new Object[]{"xiaoming"});
        Assert.assertEquals(1, (int) jdbcTemplate.queryForObject("SELECT COUNT(*) FROM test", Integer.class));
    }

    private void insert() {
        jdbcTemplate.update("INSERT INTO test(name) VALUES('xiaoming')");
        jdbcTemplate.update("INSERT INTO test(name) VALUES('xiaohong')");


        Assert.assertEquals(2, (int) jdbcTemplate.queryForObject("SELECT COUNT(*) FROM test", Integer.class));
    }


    @Test
    public void testPreparedStatement1() {
        int count = jdbcTemplate.execute(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
                return connection.prepareStatement("SELECT  COUNT(*) FROM test");
            }
        }, new PreparedStatementCallback<Integer>() {
            @Override
            public Integer doInPreparedStatement(PreparedStatement preparedStatement) throws SQLException, DataAccessException {
                preparedStatement.execute();
                ResultSet resultSet = preparedStatement.getResultSet();
                resultSet.next();
                return resultSet.getInt(1);
            }
        });

        Assert.assertEquals(0, count);
    }

    @Test
    public void testPreparedStatement2() {
        String insertSql = "insert into test(name) values(?)";
        int count = jdbcTemplate.update(insertSql, new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement preparedStatement) throws SQLException {
                preparedStatement.setObject(1, "xiaoming");
            }
        });
        Assert.assertEquals(1, count);

        String deleteSql = "delete from test where name =?";
        count = jdbcTemplate.update(deleteSql, new Object[]{"xiaoming"});
        Assert.assertEquals(1, count);
    }

    @Test
    public void testResultSet1() {
        jdbcTemplate.update("INSERT INTO test(name) VALUES('xiaoming')");
        String listSql = "select * from test";
        List result = jdbcTemplate.query(listSql, new RowMapper<Map>() {
            @Override
            public Map mapRow(ResultSet resultSet, int i) throws SQLException {
                Map row = new HashMap();
                row.put(resultSet.getInt("id"), resultSet.getString("name"));
                return row;
            }
        });

        Assert.assertEquals(1, result.size());
        jdbcTemplate.update("DELETE FROM test WHERE name='xiaoming'");
    }

    @Test
    public void testResultSet2() {
        jdbcTemplate.update("INSERT INTO test(name) VALUES('xiaoming')");
        String listSql = "select * from test";
        final List result = new ArrayList();
        jdbcTemplate.query(listSql, new RowCallbackHandler() {
            @Override
            public void processRow(ResultSet resultSet) throws SQLException {
                Map row = new HashMap();
                row.put(resultSet.getInt("id"), resultSet.getString("name"));
                result.add(row);
            }
        });
        Assert.assertEquals(1, result.size());
        jdbcTemplate.update("DELETE FROM test WHERE name='xiaoming'");
    }

    @Test
    public void testResultSet3() {
        jdbcTemplate.update("INSERT INTO test(name) VALUES('xiaoming')");
        String listSql = "select * from test";
        List result = jdbcTemplate.query(listSql, new ResultSetExtractor<List>() {
            @Override
            public List extractData(ResultSet resultSet) throws SQLException, DataAccessException {
                List result = new ArrayList();
                while (resultSet.next()) {
                    Map row = new HashMap();
                    row.put(resultSet.getInt("id"), resultSet.getString("name"));
                    result.add(row);
                }
                return result;
            }
        });

        Assert.assertEquals(1, result.size());
        jdbcTemplate.update("DELETE FROM test WHERE name='xiaoming'");
    }

    @Test
    public void testCallableStatementCreator1() {
        final String callFunctionSql = "{call FUNCTION_TEST(?)}";
        List<SqlParameter> params = new ArrayList<SqlParameter>();
        params.add(new SqlParameter(Types.VARCHAR));
        params.add(new SqlReturnResultSet("result", new ResultSetExtractor<Integer>() {
            @Override
            public Integer extractData(ResultSet resultSet) throws SQLException, DataAccessException {
                while (resultSet.next()) {
                    return resultSet.getInt(1);
                }
                return 0;
            }
        }));
        Map<String, Object> outValues = jdbcTemplate.call(new CallableStatementCreator() {
            @Override
            public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                CallableStatement callableStatement = connection.prepareCall(callFunctionSql);
                callableStatement.setString(1, "test");
                return callableStatement;
            }
        }, params);
        Assert.assertEquals(4, outValues.get("result"));
    }

    public DataSource getMysqlDataSource() {
        String url = "jdbc:mysql://localhost:3306/test";
        DriverManagerDataSource dataSource = new DriverManagerDataSource(url, "root", "123456");
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        return dataSource;
    }

    @Test
    public void testCallableStatementCreator2() {
        JdbcTemplate mysqlJdbcTemplate = new JdbcTemplate(getMysqlDataSource());
        String createFunctionSql = "CREATE FUNCTION FUNCTION_TEST(str VARCHAR(100)) returns INT return LENGTH(str)";
        String dropFunctionSql = "DROP FUNCTION IF EXISTS FUNCTION_TEST";
        mysqlJdbcTemplate.update(dropFunctionSql);
        mysqlJdbcTemplate.update(createFunctionSql);

        final String callFunctionSql = "{?= call FUNCTION_TEST(?)}";
        List<SqlParameter> params = new ArrayList<SqlParameter>();
        params.add(new SqlOutParameter("result", Types.INTEGER));
        params.add(new SqlParameter("str", Types.VARCHAR));
        Map<String, Object> outValues = mysqlJdbcTemplate.call(new CallableStatementCreator() {
            @Override
            public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                CallableStatement callableStatement = connection.prepareCall(callFunctionSql);
                callableStatement.registerOutParameter(1, Types.INTEGER);
                callableStatement.setString(2, "test1");
                return callableStatement;
            }
        }, params);
        Assert.assertEquals(5, outValues.get("result"));
    }

    @Test
    public void testCallableStatementCreator3() {
        final String callProcedureSql = "{call PROCEDURE_TEST(?,?)";
        List<SqlParameter> params = new ArrayList<SqlParameter>();
        params.add(new SqlInOutParameter("inOutName", Types.VARCHAR));
        params.add(new SqlOutParameter("outId", Types.INTEGER));
        Map<String, Object> outValues = jdbcTemplate.call(new CallableStatementCreator() {
            @Override
            public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                CallableStatement callableStatement = connection.prepareCall(callProcedureSql);
                callableStatement.registerOutParameter(1, Types.VARCHAR);
                callableStatement.registerOutParameter(2, Types.INTEGER);
                callableStatement.setString(1, "test");
                return callableStatement;
            }
        }, params);
        Assert.assertEquals("Hello,test", outValues.get("inOutName"));
        Assert.assertEquals(0, outValues.get("outId"));
    }

    @Test
    public void testPractice() {
        String[] configLocations = new String[]{
                "classpath:applicationContext-resources.xml",
                "classpath:applicationContext-jdbc.xml"};
        ApplicationContext ctx = new ClassPathXmlApplicationContext(configLocations);
        IUserDao userDao = ctx.getBean(IUserDao.class);
        UserModel model = new UserModel();
        model.setName("xiaoming");
        userDao.save(model);
        Assert.assertEquals(1, userDao.countAll());
    }
}
